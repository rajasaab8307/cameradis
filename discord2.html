<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Discord Camera</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #5865F2;
            --success-color: #57F287;
            --danger-color: #ED4245;
            --white: #ffffff;
            --overlay-bg: rgba(0, 0, 0, 0.4);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #000;
            color: var(--white);
            overflow: hidden; /* Prevent scrolling */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #camera-app {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            transform: scaleX(-1); /* Mirror for selfie view */
            transition: filter 0.3s ease-in-out;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 30%, rgba(0,0,0,0) 70%, rgba(0,0,0,0.8) 100%);
            transition: opacity 0.3s, visibility 0.3s;
        }

        #overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .top-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .bottom-controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 1rem;
        }

        #status {
            min-height: 1.2em;
            font-size: 0.9rem;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            background-color: rgba(0, 0, 0, 0.3);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            text-align: center;
            flex-grow: 1;
        }
        .status-success { color: var(--success-color); }
        .status-error { color: var(--danger-color); }

        .camera-control-button {
            background: rgba(0, 0, 0, 0.3);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--white);
            flex-shrink: 0;
        }
        .camera-control-button svg {
            width: 24px;
            height: 24px;
        }
        .camera-control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #customMessage {
            width: 100%;
            max-width: 300px;
            background-color: var(--overlay-bg);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: var(--white);
            padding: 0.6rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            text-align: center;
        }
        #customMessage::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        #customMessage:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        #captureButton {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: transparent;
            border: 5px solid var(--white);
            cursor: pointer;
            margin-top: 1rem;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #captureButton .shutter {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background-color: var(--white);
            transition: all 0.2s;
        }
        #captureButton.video-mode .shutter {
            background-color: var(--danger-color);
        }
        #captureButton.recording .shutter {
            border-radius: 10px;
            transform: scale(0.8);
        }
        #captureButton:active:not(:disabled) .shutter {
            transform: scale(0.9);
        }
        #captureButton:disabled {
            cursor: not-allowed;
            border-color: #888;
        }
        #captureButton:disabled .shutter {
            background-color: #888;
        }
        #captureButton span {
            display: none; /* Hide text */
        }

        .mode-switcher {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .mode-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            padding: 0.5rem;
            transition: color 0.2s;
        }
        .mode-button.active {
            color: var(--white);
        }

        #flash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--white);
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.1s ease-out;
        }
        #flash.animate {
            opacity: 0.9;
        }

        #spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.3);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
            z-index: 25;
        }

        @keyframes spin {
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        canvas {
            display: none;
        }

        /* Settings Panel */
        #settings-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        #settings-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .settings-content {
            background-color: #2C2F33;
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .settings-content h2 {
            margin: 0;
            text-align: center;
        }

        .settings-content label {
            font-size: 0.9rem;
            color: #99AAB5;
        }

        #webhookUrlInput {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #4F545C;
            border-radius: 6px;
            font-size: 1rem;
            background-color: #40444B;
            color: var(--white);
        }

        #saveSettingsButton {
            background-color: var(--primary-color);
            color: var(--white);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #saveSettingsButton:hover {
            background-color: #4752C4;
        }

        /* Visual Filters */
        .filter-sepia { filter: sepia(1); }
        .filter-grayscale { filter: grayscale(1); }
        .filter-invert { filter: invert(1); }
        .filter-contrast { filter: contrast(2); }
        .filter-vintage { filter: sepia(0.8) contrast(1.2) brightness(0.9) hue-rotate(-20deg); }
        .filter-warm { filter: sepia(0.4) saturate(1.5); }
        .filter-cool { filter: hue-rotate(180deg) saturate(1.5); }
        .filter-dramatic { filter: contrast(1.5) brightness(0.9); }

        /* Filter Menu */
        #filter-menu {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--overlay-bg);
            z-index: 15;
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            visibility: hidden;
            opacity: 0;
            transform: translateY(100%);
            transition: opacity 0.3s, transform 0.3s, visibility 0.3s;
        }

        #filter-menu.visible {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }

        .filter-choice-button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--white);
            padding: 0.5rem 1rem;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .filter-choice-button.active {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
    </style>
</head>
<body>

    <div id="camera-app">
        <video id="video" autoplay playsinline></video>
        <div id="flash"></div>
        <div id="spinner"></div>

        <div id="overlay">
            <div class="top-controls">
                <button id="settingsButton" class="camera-control-button" title="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 15.5q-.625 0-1.062-.438T10.5 14q0-.625.438-1.062T12 12.5q.625 0 1.062.438T13.5 14q0 .625-.438 1.062T12 15.5Zm0 5.5q-.625 0-1.062-.438T10.5 20q0-.625.438-1.062T12 18.5q.625 0 1.062.438T13.5 20q0 .625-.438 1.062T12 21Zm0-11q-.625 0-1.062-.438T10.5 9q0-.625.438-1.062T12 7.5q.625 0 1.062.438T13.5 9q0 .625-.438 1.062T12 10.5Zm0-5.5q-.625 0-1.062-.438T10.5 4q0-.625.438-1.062T12 2.5q.625 0 1.062.438T13.5 4q0 .625-.438 1.062T12 5Z"/></svg>
                </button>
                <button id="filterButton" class="camera-control-button" title="Cycle Filter">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="m12 21.2-2.1-2.1.8-1.65 1.3 1.3 1.3-1.3.8 1.65ZM4.25 18.35l-2.1-2.1.8-1.65 1.3 1.3 1.3-1.3.8 1.65ZM12 13.6q-1.9 0-3.25-1.35T7.4 9q0-1.9 1.35-3.25T12 4.4q1.9 0 3.25 1.35T16.6 9q0 1.9-1.35 3.25T12 13.6Zm7.65 4.75.8-1.65 1.3 1.3 1.3-1.3.8 1.65-2.1 2.1Zm-2.1-11.2L16.7 10l.85-1.6-2.1-2.1L14.6 7l.85 1.6ZM5.1 7 4.25 5.4l-2.1 2.1.85 1.6L3.8 8.2Zm7.7 14.2-.8-1.65 1.3-1.3 1.3 1.3-.8 1.65-2.1-2.1Z"/></svg>
                </button>
                <p id="status">Initializing...</p>
                <button id="switchCamera" class="camera-control-button" title="Switch Camera" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 20.5q-3.55 0-6.025-2.475T3.5 12q0-3.55 2.475-6.025T12 3.5q.75 0 1.275.525t.525 1.275q0 .75-.525 1.275T12 7q-2.075 0-3.538 1.463T7 12q0 2.075 1.463 3.538T12 17q2.075 0 3.538-1.463T17 12q0-.75.525-1.275T18.8 10.2q.75 0 1.275.525t.525 1.275q0 3.55-2.475 6.025T12 20.5ZM9.5 13.5v-3l4 1.5ZM12 11.1V9.9q-.5 0-.925.213t-.725.587L12 11.1Zm0 1.8v-1.2l-1.65-1.1q-.3.375-.475.8T9.7 12q0 .5.175.938T10.35 13.8Z"/></svg>
                </button>
            </div>
            <div class="bottom-controls">
                <input type="text" id="customMessage" placeholder="Add a message...">
                <button id="captureButton" disabled>
                    <div class="shutter"></div>
                    <span>Capture</span>
                </button>
                <div class="mode-switcher">
                    <button id="photoMode" class="mode-button active">Photo</button>
                    <button id="videoMode" class="mode-button">Video</button>
                </div>
            </div>
        </div>

        <div id="settings-panel">
            <div class="settings-content">
                <h2>Settings</h2>
                <label for="webhookUrlInput">Discord Webhook URL</label>
                <input type="text" id="webhookUrlInput" placeholder="Paste your webhook URL">
                <button id="saveSettingsButton">Save and Close</button>
            </div>
        </div>

        <div id="filter-menu"></div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // =================================================================================================
        //  PASTE YOUR DISCORD WEBHOOK URL HERE
        //  This URL will be used if no webhook URL is saved in the app's settings.
        //  You can get your webhook URL from your Discord server settings (Integrations -> Webhooks).
        // =================================================================================================
        let DISCORD_WEBHOOK_URL = ""; // IMPORTANT: Replace with your actual Discord Webhook URL
        // =================================================================================================
        //  END OF WEBHOOK URL CONFIGURATION
        // =================================================================================================

        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const captureButton = document.getElementById('captureButton');
        const switchCameraButton = document.getElementById('switchCamera');
        const statusElement = document.getElementById('status');
        const flashElement = document.getElementById('flash');
        const spinnerElement = document.getElementById('spinner');
        const customMessageInput = document.getElementById('customMessage');
        const overlay = document.getElementById('overlay');

        // Settings Panel Elements
        const settingsButton = document.getElementById('settingsButton');
        const settingsPanel = document.getElementById('settings-panel');
        const webhookUrlInput = document.getElementById('webhookUrlInput');
        const saveSettingsButton = document.getElementById('saveSettingsButton');

        // Filter Elements
        const filterButton = document.getElementById('filterButton');
        const filterMenu = document.getElementById('filter-menu');
        const filters = ['', 'filter-grayscale', 'filter-sepia', 'filter-warm', 'filter-cool', 'filter-dramatic', 'filter-invert', 'filter-contrast', 'filter-vintage'];
        let currentFilterClass = '';

        // Mode Switcher Elements
        const photoModeButton = document.getElementById('photoMode');
        const videoModeButton = document.getElementById('videoMode');

        let currentFacingMode = 'user';
        let stream;
        let currentMode = 'photo'; // 'photo' or 'video'
        let mediaRecorder;
        let recordedChunks = [];
        let recordingTimer;

        // --- Filter Logic ---
        function applyFilter(filterClass) {
            // Remove the previous filter class if it exists
            if (currentFilterClass) {
                video.classList.remove(currentFilterClass);
            }

            // Add the new filter class if it's not empty
            if (filterClass) {
                video.classList.add(filterClass);
            }
            currentFilterClass = filterClass;

            // Update the active state in the menu
            const buttons = filterMenu.querySelectorAll('.filter-choice-button');
            buttons.forEach(button => {
                if (button.dataset.filter === filterClass) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            const filterName = filterClass.replace('filter-', '') || 'None';
            statusElement.textContent = `Filter: ${filterName.charAt(0).toUpperCase() + filterName.slice(1)}`;
            setTimeout(() => { if(statusElement.textContent.startsWith('Filter:')) { statusElement.textContent = 'Ready'; } }, 1500);
        }

        function populateFilterMenu() {
            filterMenu.innerHTML = ''; // Clear existing buttons
            filters.forEach(filterClass => {
                const button = document.createElement('button');
                button.className = 'filter-choice-button';
                button.dataset.filter = filterClass;
                
                let displayName = filterClass.replace('filter-', '') || 'None';
                displayName = displayName.charAt(0).toUpperCase() + displayName.slice(1);
                button.textContent = displayName;

                if (filterClass === currentFilterClass) {
                    button.classList.add('active');
                }

                button.addEventListener('click', () => {
                    applyFilter(filterClass);
                    filterMenu.classList.remove('visible');
                });
                filterMenu.appendChild(button);
            });
        }

        filterButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click from closing the menu immediately
            filterMenu.classList.toggle('visible');
        });

        // Hide filter menu if clicking outside of it
        document.addEventListener('click', (e) => {
            if (!filterMenu.contains(e.target) && e.target !== filterButton) {
                filterMenu.classList.remove('visible');
            }
        });

        // --- Mode Switching ---
        function setMode(mode) {
            currentMode = mode;
            if (mode === 'photo') {
                photoModeButton.classList.add('active');
                videoModeButton.classList.remove('active');
                captureButton.classList.remove('video-mode');
                customMessageInput.style.display = 'block';
            } else {
                videoModeButton.classList.add('active');
                photoModeButton.classList.remove('active');
                captureButton.classList.add('video-mode');
                customMessageInput.style.display = 'none';
            }
        }
        photoModeButton.addEventListener('click', () => setMode('photo'));
        videoModeButton.addEventListener('click', () => setMode('video'));


        // --- Settings Panel Logic ---
        function openSettings() {
            settingsPanel.classList.add('visible');
        }

        function closeSettings() {
            settingsPanel.classList.remove('visible');
        }

        function saveSettings() {
            const newWebhookUrl = webhookUrlInput.value.trim();
            if (newWebhookUrl) {
                localStorage.setItem('discordWebhookUrl', newWebhookUrl);
                DISCORD_WEBHOOK_URL = newWebhookUrl;
                statusElement.textContent = 'Webhook URL saved!';
                statusElement.className = 'status-success';
                setTimeout(() => { statusElement.textContent = 'Ready'; statusElement.className = ''; }, 2000);
            }
            closeSettings();
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            initCamera();
        }

        function loadSettings() {
            const savedUrl = localStorage.getItem('discordWebhookUrl');
            // The hardcoded URL serves as a default, but localStorage takes precedence.
            if (savedUrl) {
                DISCORD_WEBHOOK_URL = savedUrl;
            }
            webhookUrlInput.value = DISCORD_WEBHOOK_URL;
        }

        settingsButton.addEventListener('click', openSettings);
        saveSettingsButton.addEventListener('click', saveSettings);

        // --- Sending Logic ---
        async function sendMedia(blob) {
            showSpinner(true);
            statusElement.textContent = 'Sending...';
            
            const formData = new FormData();
            const message = customMessageInput.value.trim();
            const fileName = blob.type.startsWith('image') ? 'camera-shot.png' : 'camera-video.webm';
            
            formData.append('file', blob, fileName);
            if (message && currentMode === 'photo') {
                formData.append('content', message);
            }

            try {
                const response = await fetch(DISCORD_WEBHOOK_URL, { method: 'POST', body: formData });
                if (response.ok) {
                    statusElement.textContent = 'Sent!';
                    statusElement.className = 'status-success';
                    customMessageInput.value = '';
                } else {
                    const errorText = await response.text();
                    console.error("Discord API Error:", errorText);
                    statusElement.textContent = `Send failed.`;
                    statusElement.className = 'status-error';
                }
            } catch (err) {
                console.error("Network Error:", err);
                statusElement.textContent = 'Network error.';
                statusElement.className = 'status-error';
            } finally {
                showSpinner(false);
                captureButton.disabled = false;
                switchCameraButton.disabled = false;
                setTimeout(() => { if(statusElement.textContent === 'Sent!') { statusElement.textContent = 'Ready'; statusElement.className = ''; } }, 3000);
            }
        }

        // --- Camera & Recording Logic ---
        async function initCamera() {
            loadSettings(); // Load settings at the beginning
            if (!DISCORD_WEBHOOK_URL) {
                statusElement.textContent = 'Add Webhook in Settings';
                statusElement.className = 'status-error';
                return;
            }
            try {
                const constraints = {
                    video: { 
                        facingMode: currentFacingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: true,
                };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                captureButton.disabled = false;
                switchCameraButton.disabled = false;
                statusElement.textContent = 'Ready';
                statusElement.className = '';
            } catch (err) {
                console.error("Error accessing camera: ", err);
                statusElement.textContent = 'Camera permission denied.';
                statusElement.className = 'status-error';
                captureButton.disabled = true;
                switchCameraButton.disabled = true;
            }
        }

        function triggerFlash() {
            flashElement.classList.add('animate');
            setTimeout(() => flashElement.classList.remove('animate'), 150);
        }

        function showSpinner(show) {
            spinnerElement.style.display = show ? 'block' : 'none';
        }

        function startRecording() {
            if (!stream || !MediaRecorder.isTypeSupported('video/webm')) {
                statusElement.textContent = 'Recording not supported.';
                statusElement.className = 'status-error';
                return;
            }
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                sendMedia(videoBlob);
            };
            
            mediaRecorder.start();
            captureButton.classList.add('recording');
            statusElement.textContent = 'Recording...';
            let seconds = 0;
            recordingTimer = setInterval(() => {
                seconds++;
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                statusElement.textContent = `Recording... ${mins}:${secs}`;
            }, 1000);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            captureButton.classList.remove('recording');
            clearInterval(recordingTimer);
            statusElement.textContent = 'Processing...';
        }

        captureButton.addEventListener('click', () => {
            if (!DISCORD_WEBHOOK_URL) {
                statusElement.textContent = 'Add Webhook in Settings';
                statusElement.className = 'status-error';
                openSettings();
                return;
            }

            captureButton.disabled = true;
            switchCameraButton.disabled = true;

            if (currentMode === 'photo') {
                triggerFlash();
                setTimeout(() => {
                    const context = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // Apply the current filter to the canvas context before drawing
                    const activeFilter = window.getComputedStyle(video).filter;
                    context.filter = activeFilter !== 'none' ? activeFilter : 'none';
                    
                    if (currentFacingMode === 'user') {
                        context.translate(canvas.width, 0);
                        context.scale(-1, 1);
                    }
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);
                    context.filter = 'none'; // Reset filter on context

                    canvas.toBlob((blob) => {
                        if (blob) {
                            sendMedia(blob);
                        } else {
                            statusElement.textContent = 'Capture failed.';
                            statusElement.className = 'status-error';
                            captureButton.disabled = false;
                            switchCameraButton.disabled = false;
                        }
                    }, 'image/png');
                }, 100);
            } else if (currentMode === 'video') {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    startRecording();
                    // Re-enable buttons for stopping the recording
                    captureButton.disabled = false; 
                    switchCameraButton.disabled = true; // Keep camera switch disabled during recording
                } else {
                    stopRecording();
                }
            }
        });

        switchCameraButton.addEventListener('click', () => {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            initCamera();
        });

        // --- App Initialization ---
        initCamera();
        setMode('photo');
        populateFilterMenu();
    </script>
</body>
</html>